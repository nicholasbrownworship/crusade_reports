<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crusade Intel Switcher (GM)</title>
  <meta name="color-scheme" content="dark" />

  <style>
    :root{
      --bg0:#07080b; --bg1:#0b0e14;
      --ink:#e9e6dc; --muted:#b7b1a2; --dim:#7d776b;
      --gold:#d1a14b; --red:#cc3b3b; --green:#3fbf7f; --blue:#4aa6ff;
      --panel: rgba(10, 12, 18, 0.72);
      --panel2: rgba(12, 14, 20, 0.55);
      --line: rgba(209, 161, 75, 0.18);
      --shadow: 0 18px 55px rgba(0,0,0,0.55);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(209,161,75,0.10), transparent 60%),
        radial-gradient(800px 600px at 70% 20%, rgba(74,166,255,0.08), transparent 60%),
        radial-gradient(700px 600px at 50% 80%, rgba(63,191,127,0.06), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
      overflow-x:hidden;
    }

    .wrap{ max-width: 1180px; margin: 0 auto; padding: 28px 18px 60px; }

    header{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom: 18px;
    }

    .title{ display:flex; flex-direction:column; gap:6px; }
    h1{
      margin:0;
      font-size: 22px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
    }
    .sub{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
      max-width: 92ch;
    }

    .pill{
      font-size: 11px;
      color: var(--muted);
      border: 1px solid rgba(209,161,75,0.14);
      background: rgba(0,0,0,0.18);
      padding: 6px 9px;
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }

    .panel{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .tabs{
      display:flex;
      gap:10px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(209,161,75,0.14);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent);
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }

    .tabset{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .tab{
      border: 1px solid rgba(209,161,75,0.22);
      background: rgba(209,161,75,0.08);
      color: var(--ink);
      border-radius: 999px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight: 750;
      letter-spacing: 0.4px;
      user-select:none;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .tab small{ color: var(--muted); font-weight: 650; }
    .tab.active{
      border-color: rgba(74,166,255,0.55);
      background: rgba(74,166,255,0.16);
      box-shadow: 0 0 0 6px rgba(74,166,255,0.08);
    }

    .topactions{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    button{
      appearance:none;
      border: 1px solid rgba(209,161,75,0.25);
      background: rgba(209,161,75,0.10);
      color: var(--ink);
      border-radius: 14px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight: 650;
      letter-spacing: 0.3px;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    button:hover{ background: rgba(209,161,75,0.16); border-color: rgba(209,161,75,0.35); }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: rgba(74,166,255,0.12);
      border-color: rgba(74,166,255,0.35);
    }
    button.primary:hover{
      background: rgba(74,166,255,0.18);
      border-color: rgba(74,166,255,0.5);
    }
    button.danger{
      background: rgba(204,59,59,0.12);
      border-color: rgba(204,59,59,0.35);
    }
    button.danger:hover{
      background: rgba(204,59,59,0.18);
      border-color: rgba(204,59,59,0.5);
    }

    .controls{
      display:grid;
      grid-template-columns: 0.7fr 1fr 0.9fr 1.6fr 1.3fr auto;
      gap:10px;
      padding: 14px;
      border-bottom: 1px solid rgba(209,161,75,0.14);
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 140px;
    }

    label{
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.9px;
    }

    select, input[type="number"], input[type="text"], input[type="password"]{
      background: rgba(255,255,255,0.04);
      color: var(--ink);
      border: 1px solid rgba(209,161,75,0.18);
      border-radius: 12px;
      padding: 10px 10px;
      outline: none;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.35fr 0.65fr;
      gap: 14px;
      padding: 14px;
    }
    @media (max-width: 1060px){
      .controls{ grid-template-columns: 1fr 1fr; }
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--panel2);
      border: 1px solid rgba(209,161,75,0.14);
      border-radius: 16px;
      padding: 14px;
      position:relative;
      overflow:hidden;
    }
    .card:before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(550px 120px at 0% 0%, rgba(209,161,75,0.10), transparent 60%),
        radial-gradient(500px 160px at 100% 0%, rgba(74,166,255,0.08), transparent 60%);
      pointer-events:none;
    }
    .card > *{ position:relative; }

    .badge{
      font-size: 11px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      color: var(--muted);
      border: 1px solid rgba(209,161,75,0.18);
      background: rgba(255,255,255,0.03);
      padding: 6px 9px;
      border-radius: 999px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    .dot{ width:8px; height:8px; border-radius: 999px; background: var(--gold); box-shadow: 0 0 0 2px rgba(209,161,75,0.18); }
    .dot.low{ background: var(--dim); box-shadow: 0 0 0 2px rgba(125,119,107,0.20); }
    .dot.mod{ background: var(--gold); }
    .dot.high{ background: var(--green); box-shadow: 0 0 0 2px rgba(63,191,127,0.20); }

    .ctitle{ margin:0; font-size: 16px; letter-spacing: 0.2px; }
    .ctext{ margin: 8px 0 0; color: var(--ink); line-height: 1.55; font-size: 14px; }

    .meta{
      margin-top: 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .meta .left{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .actions{ display:flex; gap:8px; flex-wrap:wrap; }

    .stack{ display:flex; flex-direction:column; gap:10px; }

    .small{ font-size: 12px; color: var(--muted); line-height:1.45; }
    .small.warn{ color: #ffd38a; }
    .small.err{ color: var(--red); }

    .history{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height: 420px;
      overflow:auto;
      padding-right: 4px;
    }

    .hitem{
      border: 1px solid rgba(209,161,75,0.12);
      background: rgba(0,0,0,0.18);
      border-radius: 14px;
      padding: 10px;
    }
    .hitem .top{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .hitem .top b{
      font-size: 12px;
      letter-spacing: 0.2px;
    }
    .hitem .time{
      font-size: 11px;
      color: var(--dim);
      white-space:nowrap;
    }
    .hitem .desc{
      margin-top:6px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.60);
      border: 1px solid rgba(209,161,75,0.22);
      color: var(--ink);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .16s ease, transform .16s ease;
      font-size: 12px;
      max-width: min(860px, calc(100vw - 26px));
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-4px);
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 8px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Crusade Intel Switcher (GM)</h1>
        <div class="sub">
          Three independent ‚Äúprogram feeds.‚Äù Send players the matching links:
          <span class="kbd">viewer.html?room=defenders</span>,
          <span class="kbd">viewer.html?room=raiders</span>,
          <span class="kbd">viewer.html?room=attackers</span>.
          Hotkeys: <span class="kbd">D</span> draw ‚Ä¢ <span class="kbd">C</span> copy.
        </div>
      </div>
      <div class="pill" id="netPill">Backend: Booting‚Ä¶</div>
    </header>

    <section class="panel">
      <div class="tabs">
        <div class="tabset" id="tabset"></div>
        <div class="topactions">
          <button id="loadBtn">Load Room</button>
          <button class="primary" id="publishBtn">Publish Room</button>
          <button id="publishAllBtn" title="Publish each room using its current pinned board">Publish All</button>
          <button class="danger" id="resetLocalBtn">Reset Local</button>
        </div>
      </div>

      <div class="controls">
        <div class="field">
          <label for="count">Draw Count</label>
          <input id="count" type="number" min="1" max="8" value="3" />
        </div>

        <div class="field">
          <label for="category">Category Filter</label>
          <select id="category">
            <option value="__all__">All Categories</option>
          </select>
        </div>

        <div class="field">
          <label for="mode">Draw Mode</label>
          <select id="mode">
            <option value="unique">Unique</option>
            <option value="any">Any</option>
          </select>
        </div>

        <div class="field">
          <label for="subtitle">Viewer Subtitle (Room)</label>
          <input id="subtitle" type="text" placeholder="Optional line shown to that room‚Ä¶" />
        </div>

        <div class="field">
          <label for="gmKey">GM Key (Room)</label>
          <input id="gmKey" type="password" placeholder="Key for selected room" />
        </div>

        <div class="btnrow">
          <button class="primary" id="drawBtn">Draw</button>
          <button id="copyBtn">Copy</button>
        </div>
      </div>

      <div class="grid">
        <div class="leftcol stack">
          <div class="card">
            <div class="small" id="deckStatus">Loading deck‚Ä¶</div>
            <div class="small" id="roomStatus" style="margin-top:6px;">Loading room state‚Ä¶</div>
            <div class="small warn" style="margin-top:8px;">
              Keys live in your browser only. Don‚Äôt commit keys into GitHub.
            </div>
          </div>

          <div id="drawArea" class="stack"></div>
        </div>

        <div class="rightcol stack">
          <div class="card">
            <h3 class="ctitle" style="margin:0 0 6px;">Pinned / Status Board (This Room)</h3>
            <div class="small">This room‚Äôs published feed. Focus highlights a single card on the viewer.</div>
            <div class="history" id="statusBoard"></div>
          </div>

          <div class="card">
            <h3 class="ctitle" style="margin:0 0 6px;">Draw History (Local)</h3>
            <div class="small">Just for your GM screen.</div>
            <div class="history" id="history"></div>
          </div>
        </div>
      </div>
    </section>

    <div class="toast" id="toast"></div>
  </div>

<script>
(() => {
  // ===== CONFIG =====
  const APPS_SCRIPT_BASE =
    "https://script.google.com/macros/s/AKfycbwKW6HJ2DkpxoAqLgwA5AeeA9_GvlBq7Fc8svttiLyML14wRUDuI5KAH7iQO4ns0hds/exec";
  const DECK_URL = "./briefing_deck.json";

  const ROOMS = [
    { id: "defenders", label: "Defenders" },
    { id: "raiders",   label: "Raiders" },
    { id: "attackers", label: "Attackers" }
  ];

  // ===== STORAGE KEYS =====
  const LS = {
    seen: "crusadeIntel_seen_v1",
    history: "crusadeIntel_history_v1",
    activeRoom: "crusadeIntel_activeRoom_v1",

    // per-room local cache + per-room GM key
    roomState: (room) => `crusadeIntel_room_state_${room}_v1`,
    roomKey:   (room) => `crusadeIntel_room_key_${room}_v1`
  };

  // ===== ELEMENTS =====
  const els = {
    netPill: document.getElementById("netPill"),
    tabset: document.getElementById("tabset"),

    loadBtn: document.getElementById("loadBtn"),
    publishBtn: document.getElementById("publishBtn"),
    publishAllBtn: document.getElementById("publishAllBtn"),
    resetLocalBtn: document.getElementById("resetLocalBtn"),

    count: document.getElementById("count"),
    category: document.getElementById("category"),
    mode: document.getElementById("mode"),
    subtitle: document.getElementById("subtitle"),
    gmKey: document.getElementById("gmKey"),

    drawBtn: document.getElementById("drawBtn"),
    copyBtn: document.getElementById("copyBtn"),

    deckStatus: document.getElementById("deckStatus"),
    roomStatus: document.getElementById("roomStatus"),

    drawArea: document.getElementById("drawArea"),
    statusBoard: document.getElementById("statusBoard"),
    history: document.getElementById("history"),
    toast: document.getElementById("toast")
  };

  // ===== STATE =====
  let DECK = null;
  let lastDraw = [];
  let activeRoom = loadPlain(LS.activeRoom, "defenders");

  // Per-room program feed states
  const roomStates = {
    defenders: loadRoomCache("defenders"),
    raiders:   loadRoomCache("raiders"),
    attackers: loadRoomCache("attackers")
  };

  // ===== HELPERS =====
  function escapeHtml(str){
    return String(str ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function toast(msg){
    els.toast.textContent = msg;
    els.toast.classList.add("show");
    window.clearTimeout(toast._t);
    toast._t = window.setTimeout(() => els.toast.classList.remove("show"), 1400);
  }

  function loadJSON(key, fallback){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return fallback;
      return JSON.parse(raw);
    }catch(e){
      return fallback;
    }
  }
  function saveJSON(key, val){
    localStorage.setItem(key, JSON.stringify(val));
  }
  function loadPlain(key, fallback){
    try{
      const raw = localStorage.getItem(key);
      if(raw === null || raw === undefined) return fallback;
      return String(raw).replaceAll('"','') || fallback;
    }catch(e){
      return fallback;
    }
  }
  function savePlain(key, val){
    localStorage.setItem(key, String(val));
  }

  function normalizeState(s){
    const out = {
      updatedAt: Number(s?.updatedAt || 0),
      subtitle: String(s?.subtitle || ""),
      focusCardId: String(s?.focusCardId || ""),
      pinned: Array.isArray(s?.pinned) ? s.pinned.map(p => ({
        card_id: String(p.card_id || ""),
        status: String(p.status || "ongoing"),
        note: String(p.note || "")
      })).filter(p => p.card_id) : []
    };
    return out;
  }

  function emptyState(){
    return { updatedAt: 0, subtitle: "", pinned: [], focusCardId: "" };
  }

  function loadRoomCache(room){
    const cached = loadJSON(LS.roomState(room), null);
    return cached ? normalizeState(cached) : emptyState();
  }

  function saveRoomCache(room){
    saveJSON(LS.roomState(room), roomStates[room]);
  }

  function getRoom(){
    return activeRoom;
  }

  function getState(){
    return roomStates[getRoom()];
  }

  function setNet(ok, msg){
    els.netPill.textContent = ok ? `Backend: Online` : `Backend: Offline`;
    els.netPill.style.borderColor = ok ? "rgba(63,191,127,0.35)" : "rgba(204,59,59,0.35)";
    els.netPill.style.background = ok ? "rgba(63,191,127,0.10)" : "rgba(204,59,59,0.10)";
    if(msg) els.roomStatus.textContent = msg;
  }

  function confidenceDotClass(conf){
    const c = (conf || "").toLowerCase();
    if(c.includes("high")) return "high";
    if(c.includes("mod")) return "mod";
    return "low";
  }

  function statusLabel(status){
    switch((status||"").toLowerCase()){
      case "ongoing": return "Ongoing";
      case "resolved": return "Resolved";
      case "false": return "Misinformation";
      default: return "Pinned";
    }
  }

  function ensureCategoryOptions(cards){
    const cats = Array.from(new Set(cards.map(c => c.category))).sort();
    while(els.category.options.length > 1) els.category.remove(1);
    for(const cat of cats){
      const opt = document.createElement("option");
      opt.value = cat;
      opt.textContent = cat;
      els.category.appendChild(opt);
    }
  }

  function eligibleCards(cards){
    const cat = els.category.value;
    return cards.filter(c => (cat === "__all__" ? true : c.category === cat));
  }

  function drawCards(cards, count, mode){
    const pool = eligibleCards(cards);
    if(pool.length === 0) return [];

    if(mode === "any"){
      const out = [];
      for(let i=0;i<count;i++){
        out.push(pool[Math.floor(Math.random()*pool.length)]);
      }
      return out;
    }

    let seen = new Set(loadJSON(LS.seen, []));
    let unseen = pool.filter(c => !seen.has(c.id));

    if(unseen.length < count){
      for(const c of pool){ seen.delete(c.id); }
      unseen = pool.slice();
      toast("Deck cycle refreshed for current filter.");
    }

    const out = [];
    const bag = unseen.slice();
    for(let i=0;i<count && bag.length;i++){
      const idx = Math.floor(Math.random()*bag.length);
      out.push(bag.splice(idx,1)[0]);
    }

    for(const c of out) seen.add(c.id);
    saveJSON(LS.seen, Array.from(seen));
    return out;
  }

  function apiGetUrl(room){
    return `${APPS_SCRIPT_BASE}?room=${encodeURIComponent(room)}`;
  }

  async function apiGetState(room){
    const res = await fetch(apiGetUrl(room), { cache: "no-store" });
    if(!res.ok) throw new Error(`GET failed (${res.status})`);
    const data = await res.json();
    if(!data || data.ok !== true) throw new Error(data?.error || "GET ok:false");
    return data.state;
  }

  async function apiPostState(room, state){
    const key = (els.gmKey.value || "").trim();
    if(!key) throw new Error("GM Key is blank for this room.");

    const payload = { room, key, state };

    const res = await fetch(APPS_SCRIPT_BASE, {
      method: "POST",
      headers: { "Content-Type": "text/plain;charset=utf-8" },
      body: JSON.stringify(payload)
    });

    const data = await res.json().catch(() => null);
    if(!data || data.ok !== true){
      throw new Error(data?.error || `Publish failed (${res.status}).`);
    }
    return data.state;
  }

  // ===== RENDER =====
  function deckStatusLine(){
    const total = (DECK?.cards || []).length;
    const cat = els.category.value;
    const pool = eligibleCards(DECK.cards);
    const seen = new Set(loadJSON(LS.seen, []));
    const poolSeen = pool.filter(c => seen.has(c.id)).length;
    const poolUnseen = pool.length - poolSeen;

    const catText = (cat === "__all__") ? "All Categories" : cat;
    return `Deck: ${total} cards ‚Ä¢ Filter: ${catText} ‚Ä¢ Unique cycle: ${poolUnseen} unseen / ${pool.length}`;
  }

  function renderTabs(){
    els.tabset.innerHTML = "";
    for(const r of ROOMS){
      const btn = document.createElement("button");
      btn.className = "tab" + (r.id === activeRoom ? " active" : "");
      const s = roomStates[r.id];
      const count = (s?.pinned || []).length;
      btn.innerHTML = `${escapeHtml(r.label)} <small>(${count})</small>`;
      btn.addEventListener("click", () => {
        activeRoom = r.id;
        savePlain(LS.activeRoom, activeRoom);
        syncRoomFieldsFromState();
        renderTabs();
        renderStatusBoard();
        renderDraw(lastDraw);
        toast(`Switched: ${r.label}`);
      });
      els.tabset.appendChild(btn);
    }
  }

  function syncRoomFieldsFromState(){
    const room = getRoom();
    const state = getState();
    // load per-room key into input
    const savedKey = loadPlain(LS.roomKey(room), "");
    els.gmKey.value = savedKey;
    els.subtitle.value = state.subtitle || "";
    els.roomStatus.textContent = `Room: ${room} ‚Ä¢ Updated: ${state.updatedAt ? new Date(state.updatedAt).toLocaleString() : "‚Äî"}`;
  }

  function renderDraw(cards){
    els.drawArea.innerHTML = "";
    if(!cards.length){
      els.drawArea.innerHTML = `<div class="card"><div class="small">No cards drawn yet.</div></div>`;
      return;
    }
    for(const c of cards){
      els.drawArea.appendChild(makeDrawCardEl(c));
    }
  }

  function upsertPinned(state, cardId, status, note){
    const idx = state.pinned.findIndex(p => p.card_id === cardId);
    const entry = {
      card_id: cardId,
      status: status || "ongoing",
      note: (note || "").slice(0, 200)
    };
    if(idx === -1) state.pinned.unshift(entry);
    else state.pinned[idx] = entry;
  }

  function makeDrawCardEl(c){
    const state = getState();
    const existing = state.pinned.find(p => p.card_id === c.id);
    const currentStatus = existing?.status || "";
    const currentNote = existing?.note || "";

    const wrap = document.createElement("div");
    wrap.className = "card";

    wrap.innerHTML = `
      <div class="cardhead">
        <div>
          <div class="badge">
            <span class="dot ${confidenceDotClass(c.confidence)}"></span>
            <span>${escapeHtml(c.category)}</span>
            <span style="opacity:.65">‚Ä¢</span>
            <span>${escapeHtml((c.confidence || "Low"))} Confidence</span>
          </div>
          <h3 class="ctitle">${escapeHtml(c.title)}</h3>
        </div>
        <div class="pill">${escapeHtml(statusLabel(currentStatus || "pinned"))}</div>
      </div>

      <p class="ctext">${escapeHtml(c.text)}</p>

      <div class="meta">
        <div class="left">
          ${(c.tone || []).slice(0,4).map(t => `<span class="pill">#${escapeHtml(t)}</span>`).join("")}
          ${currentNote ? `<span class="pill" title="GM note">üóí ${escapeHtml(currentNote)}</span>` : ``}
        </div>
        <div class="actions">
          <button data-act="pin">Pin</button>
          <button data-act="ongoing">Ongoing</button>
          <button data-act="resolved">Resolved</button>
          <button data-act="false">Misinformation</button>
          <button data-act="note">Add Note</button>
          <button data-act="focus">Focus</button>
          <button data-act="unpin">Unpin</button>
        </div>
      </div>
    `;

    wrap.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        const act = btn.getAttribute("data-act");
        const state = getState();

        if(act === "note"){
          const current = state.pinned.find(p => p.card_id === c.id)?.note || "";
          const next = prompt("GM note (short):", current);
          if(next === null) return;
          upsertPinned(state, c.id, currentStatus || "ongoing", next.trim());
          state.focusCardId = c.id;
          saveRoomCache(getRoom());
          renderStatusBoard();
          renderDraw(lastDraw);
          toast("Note saved (local). Publish when ready.");
          return;
        }

        if(act === "focus"){
          state.focusCardId = c.id;
          if(!state.pinned.some(p => p.card_id === c.id)){
            upsertPinned(state, c.id, "ongoing", "");
          }
          saveRoomCache(getRoom());
          renderStatusBoard();
          renderDraw(lastDraw);
          toast("Focused (local). Publish when ready.");
          return;
        }

        if(act === "unpin"){
          state.pinned = state.pinned.filter(p => p.card_id !== c.id);
          if(state.focusCardId === c.id) state.focusCardId = "";
          saveRoomCache(getRoom());
          renderStatusBoard();
          renderDraw(lastDraw);
          toast("Unpinned (local). Publish when ready.");
          return;
        }

        const status = (act === "pin") ? "ongoing" : act;
        upsertPinned(state, c.id, status, currentNote || "");
        state.focusCardId = c.id;
        saveRoomCache(getRoom());
        renderStatusBoard();
        renderDraw(lastDraw);
        toast(`${statusLabel(status)} (local). Publish when ready.`);
      });
    });

    return wrap;
  }

  function renderStatusBoard(){
    const state = getState();
    els.statusBoard.innerHTML = "";
    if(!state.pinned.length){
      els.statusBoard.innerHTML = `<div class="small">No pinned intel in this room yet.</div>`;
      return;
    }

    for(const p of state.pinned){
      const card = (DECK?.cards || []).find(c => c.id === p.card_id);
      if(!card) continue;

      const isFocus = state.focusCardId === p.card_id;

      const el = document.createElement("div");
      el.className = "hitem";
      el.innerHTML = `
        <div class="top">
          <b>${escapeHtml(card.title)}${isFocus ? " ‚Ä¢ (FOCUS)" : ""}</b>
          <span class="time">${escapeHtml(card.category)}</span>
        </div>
        <div class="desc">
          <span class="pill">${escapeHtml(statusLabel(p.status))}</span>
          ${p.note ? `<div style="margin-top:6px; color: var(--muted);">${escapeHtml(p.note)}</div>` : ``}
          <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
            <button data-sb="focus">Focus</button>
            <button data-sb="up">Up</button>
            <button data-sb="down">Down</button>
            <button data-sb="remove">Remove</button>
          </div>
        </div>
      `;

      el.querySelector('[data-sb="focus"]').addEventListener("click", () => {
        const state = getState();
        state.focusCardId = p.card_id;
        saveRoomCache(getRoom());
        renderStatusBoard();
        renderDraw(lastDraw);
        toast("Focus set (local). Publish when ready.");
      });

      el.querySelector('[data-sb="remove"]').addEventListener("click", () => {
        const state = getState();
        state.pinned = state.pinned.filter(x => x.card_id !== p.card_id);
        if(state.focusCardId === p.card_id) state.focusCardId = "";
        saveRoomCache(getRoom());
        renderStatusBoard();
        renderDraw(lastDraw);
        toast("Removed (local). Publish when ready.");
      });

      el.querySelector('[data-sb="up"]').addEventListener("click", () => {
        const state = getState();
        const i = state.pinned.findIndex(x => x.card_id === p.card_id);
        if(i > 0){
          const tmp = state.pinned[i-1];
          state.pinned[i-1] = state.pinned[i];
          state.pinned[i] = tmp;
          saveRoomCache(getRoom());
          renderStatusBoard();
          toast("Reordered (local). Publish when ready.");
        }
      });

      el.querySelector('[data-sb="down"]').addEventListener("click", () => {
        const state = getState();
        const i = state.pinned.findIndex(x => x.card_id === p.card_id);
        if(i !== -1 && i < state.pinned.length - 1){
          const tmp = state.pinned[i+1];
          state.pinned[i+1] = state.pinned[i];
          state.pinned[i] = tmp;
          saveRoomCache(getRoom());
          renderStatusBoard();
          toast("Reordered (local). Publish when ready.");
        }
      });

      els.statusBoard.appendChild(el);
    }
  }

  function renderHistory(){
    const hist = loadJSON(LS.history, []);
    els.history.innerHTML = "";
    if(hist.length === 0){
      els.history.innerHTML = `<div class="small">No draws yet.</div>`;
      return;
    }

    for(const h of hist.slice(0, 30)){
      const el = document.createElement("div");
      el.className = "hitem";
      el.innerHTML = `
        <div class="top">
          <b>${escapeHtml(h.title)}</b>
          <span class="time">${escapeHtml(h.time)}</span>
        </div>
        <div class="desc">${escapeHtml(h.category)} ‚Ä¢ ${escapeHtml(h.confidence || "Low")} Confidence</div>
      `;
      els.history.appendChild(el);
    }
  }

  function appendHistory(drawn){
    const hist = loadJSON(LS.history, []);
    const stamp = new Date().toLocaleString();
    for(const c of drawn){
      hist.unshift({
        id: c.id,
        title: c.title,
        category: c.category,
        confidence: c.confidence,
        time: stamp
      });
    }
    saveJSON(LS.history, hist.slice(0, 120));
    renderHistory();
  }

  // ===== BACKEND OPS =====
  async function loadRoomFromBackend(room){
    setNet(true, `Loading backend room: ${room}‚Ä¶`);
    const s = await apiGetState(room);
    roomStates[room] = normalizeState(s);
    saveRoomCache(room);
    setNet(true, `Loaded ${room} ‚Ä¢ Updated: ${roomStates[room].updatedAt ? new Date(roomStates[room].updatedAt).toLocaleString() : "‚Äî"}`);
  }

  async function publishRoomToBackend(room){
    // save subtitle from field into this room's state
    if(room === getRoom()){
      roomStates[room].subtitle = els.subtitle.value.trim();
      saveRoomCache(room);
    }

    // pull key for that room into input (so publishing works even if we switched)
    const key = loadPlain(LS.roomKey(room), "");
    if(room !== getRoom()){
      // temporarily use that key for posting; don't disturb current room key field
      return await publishRoomWithKey(room, key);
    } else {
      // current room uses current gmKey input
      return await publishRoomWithKey(room, (els.gmKey.value || "").trim());
    }
  }

  async function publishRoomWithKey(room, key){
    if(!key) throw new Error(`GM Key missing for room: ${room}`);
    setNet(true, `Publishing ${room}‚Ä¶`);

    // local copy so we don't mutate mid-flight
    const state = normalizeState(roomStates[room]);
    state.subtitle = String(state.subtitle || "");
    // note: server stamps updatedAt too, but keep placeholder
    state.updatedAt = Date.now();

    const payload = { room, key, state };

    const res = await fetch(APPS_SCRIPT_BASE, {
      method: "POST",
      headers: { "Content-Type": "text/plain;charset=utf-8" },
      body: JSON.stringify(payload)
    });

    const data = await res.json().catch(() => null);
    if(!data || data.ok !== true){
      throw new Error(data?.error || `Publish failed (${res.status}).`);
    }

    roomStates[room] = normalizeState(data.state);
    saveRoomCache(room);

    setNet(true, `Published ${room} ‚Ä¢ Updated: ${new Date(roomStates[room].updatedAt || Date.now()).toLocaleString()}`);
  }

  // ===== INIT =====
  async function init(){
    // Build tabs
    renderTabs();

    // Load deck
    try{
      const res = await fetch(DECK_URL, { cache: "no-store" });
      if(!res.ok) throw new Error(`Failed to load ${DECK_URL} (${res.status})`);
      DECK = await res.json();
      ensureCategoryOptions(DECK.cards);
      els.deckStatus.textContent = deckStatusLine();
    }catch(err){
      els.deckStatus.textContent = "Failed to load deck. Check briefing_deck.json in repo root.";
      els.roomStatus.textContent = err.message || String(err);
      setNet(false, "Deck load failed.");
      return;
    }

    // Sync room fields from local cache
    syncRoomFieldsFromState();
    renderStatusBoard();
    renderHistory();
    renderDraw([]);

    // Save key per room when you type it
    els.gmKey.addEventListener("input", () => {
      savePlain(LS.roomKey(getRoom()), els.gmKey.value);
    });

    // Subtitle is per room
    els.subtitle.addEventListener("input", () => {
      const state = getState();
      state.subtitle = els.subtitle.value;
      saveRoomCache(getRoom());
    });

    // Controls
    els.category.addEventListener("change", () => {
      els.deckStatus.textContent = deckStatusLine();
    });

    els.drawBtn.addEventListener("click", () => {
      const count = Math.max(1, Math.min(8, parseInt(els.count.value || "3", 10)));
      els.count.value = String(count);

      const mode = els.mode.value;
      lastDraw = drawCards(DECK.cards, count, mode);
      renderDraw(lastDraw);
      appendHistory(lastDraw);
      els.deckStatus.textContent = deckStatusLine();
      toast(`Drew ${lastDraw.length} card(s).`);
    });

    els.copyBtn.addEventListener("click", async () => {
      if(!lastDraw.length){
        toast("Nothing to copy. Draw first.");
        return;
      }
      const stamp = new Date().toLocaleString();
      const lines = [];
      lines.push(`CRUSADE INTEL BRIEFING ‚Äî ROOM: ${getRoom().toUpperCase()}`);
      lines.push(`Generated: ${stamp}`);
      lines.push("");

      for(const c of lastDraw){
        lines.push(`[${c.category}] ${c.title} (${c.confidence || "Low"} Confidence)`);
        lines.push(c.text);
        lines.push("");
      }

      const txt = lines.join("\n");
      try{
        await navigator.clipboard.writeText(txt);
        toast("Copied.");
      }catch(e){
        prompt("Copy briefing:", txt);
      }
    });

    els.loadBtn.addEventListener("click", async () => {
      const room = getRoom();
      try{
        await loadRoomFromBackend(room);
        syncRoomFieldsFromState();
        renderTabs();
        renderStatusBoard();
        renderDraw(lastDraw);
        toast("Loaded room from backend.");
      }catch(err){
        setNet(false, `Load failed: ${err.message || String(err)}`);
        toast("Load failed (see status).");
      }
    });

    els.publishBtn.addEventListener("click", async () => {
      const room = getRoom();
      try{
        // ensure UI subtitle -> room state
        roomStates[room].subtitle = els.subtitle.value.trim();
        saveRoomCache(room);

        await publishRoomWithKey(room, (els.gmKey.value || "").trim());
        syncRoomFieldsFromState();
        renderTabs();
        toast("Published room.");
      }catch(err){
        setNet(false, `Publish failed: ${err.message || String(err)}`);
        toast("Publish failed (see status).");
      }
    });

    els.publishAllBtn.addEventListener("click", async () => {
      try{
        // commit active room subtitle before publishing all
        roomStates[getRoom()].subtitle = els.subtitle.value.trim();
        saveRoomCache(getRoom());

        for(const r of ROOMS){
          const key = loadPlain(LS.roomKey(r.id), "");
          await publishRoomWithKey(r.id, key);
        }
        renderTabs();
        toast("Published all rooms.");
      }catch(err){
        setNet(false, `Publish all failed: ${err.message || String(err)}`);
        toast("Publish all failed (see status).");
      }
    });

    els.resetLocalBtn.addEventListener("click", () => {
      if(!confirm("Reset LOCAL draw history + unique-cycle? (Does not erase backend.)")) return;
      localStorage.removeItem(LS.seen);
      localStorage.removeItem(LS.history);
      lastDraw = [];
      renderHistory();
      renderDraw([]);
      els.deckStatus.textContent = deckStatusLine();
      toast("Local reset done.");
    });

    // Hotkeys
    window.addEventListener("keydown", (e) => {
      if(e.key.toLowerCase() === "d") els.drawBtn.click();
      if(e.key.toLowerCase() === "c") els.copyBtn.click();
    });

    setNet(true, `Ready ‚Ä¢ Active room: ${getRoom()}`);
    toast("Switcher ready. Publish a room to push updates.");
  }

  init();
})();
</script>
</body>
</html>

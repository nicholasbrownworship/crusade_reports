<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Crusade Intelligence Briefings (GM)</title>
  <meta name="color-scheme" content="dark" />

  <style>
    :root{
      --bg0:#07080b;
      --bg1:#0b0e14;
      --ink:#e9e6dc;
      --muted:#b7b1a2;
      --dim:#7d776b;

      --gold:#d1a14b;
      --red:#cc3b3b;
      --green:#3fbf7f;
      --blue:#4aa6ff;

      --panel: rgba(10, 12, 18, 0.72);
      --panel2: rgba(12, 14, 20, 0.55);
      --line: rgba(209, 161, 75, 0.18);
      --shadow: 0 18px 55px rgba(0,0,0,0.55);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(209,161,75,0.10), transparent 60%),
        radial-gradient(800px 600px at 70% 20%, rgba(74,166,255,0.08), transparent 60%),
        radial-gradient(700px 600px at 50% 80%, rgba(63,191,127,0.06), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
      overflow-x:hidden;
    }

    .wrap{ max-width: 1120px; margin: 0 auto; padding: 28px 18px 60px; }

    header{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom: 18px;
    }

    .title{ display:flex; flex-direction:column; gap:6px; }

    h1{
      margin:0;
      font-size: 22px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
    }
    .sub{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
      max-width: 84ch;
    }

    .panel{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .controls{
      display:grid;
      grid-template-columns: 0.8fr 0.9fr 0.9fr 1.2fr 1.2fr auto;
      gap:10px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent);
      border-bottom: 1px solid rgba(209,161,75,0.14);
    }

    .controls .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 140px;
    }

    label{
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.9px;
    }

    select, input[type="number"], input[type="text"], input[type="password"]{
      background: rgba(255,255,255,0.04);
      color: var(--ink);
      border: 1px solid rgba(209,161,75,0.18);
      border-radius: 12px;
      padding: 10px 10px;
      outline: none;
    }

    .btnrow{
      display:flex;
      gap:10px;
      align-items:flex-end;
      justify-content:flex-end;
      flex-wrap:wrap;
    }

    button{
      appearance:none;
      border: 1px solid rgba(209,161,75,0.25);
      background: rgba(209,161,75,0.10);
      color: var(--ink);
      border-radius: 14px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight: 650;
      letter-spacing: 0.3px;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    button:hover{ background: rgba(209,161,75,0.16); border-color: rgba(209,161,75,0.35); }
    button:active{ transform: translateY(1px); }

    button.primary{
      background: rgba(74,166,255,0.12);
      border-color: rgba(74,166,255,0.35);
    }
    button.primary:hover{
      background: rgba(74,166,255,0.18);
      border-color: rgba(74,166,255,0.5);
    }

    button.danger{
      background: rgba(204,59,59,0.12);
      border-color: rgba(204,59,59,0.35);
    }
    button.danger:hover{
      background: rgba(204,59,59,0.18);
      border-color: rgba(204,59,59,0.5);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.35fr 0.65fr;
      gap: 14px;
      padding: 14px;
    }

    @media (max-width: 1020px){
      .controls{ grid-template-columns: 1fr 1fr; }
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--panel2);
      border: 1px solid rgba(209,161,75,0.14);
      border-radius: 16px;
      padding: 14px;
      position:relative;
      overflow:hidden;
    }

    .card:before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(550px 120px at 0% 0%, rgba(209,161,75,0.10), transparent 60%),
        radial-gradient(500px 160px at 100% 0%, rgba(74,166,255,0.08), transparent 60%);
      pointer-events:none;
    }

    .card > *{ position:relative; }

    .cardhead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 10px;
    }

    .badge{
      font-size: 11px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      color: var(--muted);
      border: 1px solid rgba(209,161,75,0.18);
      background: rgba(255,255,255,0.03);
      padding: 6px 9px;
      border-radius: 999px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    .dot{ width:8px; height:8px; border-radius: 999px; background: var(--gold); box-shadow: 0 0 0 2px rgba(209,161,75,0.18); }
    .dot.low{ background: var(--dim); box-shadow: 0 0 0 2px rgba(125,119,107,0.20); }
    .dot.mod{ background: var(--gold); }
    .dot.high{ background: var(--green); box-shadow: 0 0 0 2px rgba(63,191,127,0.20); }

    .ctitle{ margin:0; font-size: 16px; letter-spacing: 0.2px; }
    .ctext{ margin: 8px 0 0; color: var(--ink); line-height: 1.55; font-size: 14px; }

    .meta{
      margin-top: 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }

    .meta .left{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    .pill{
      font-size: 11px;
      color: var(--muted);
      border: 1px solid rgba(209,161,75,0.14);
      background: rgba(0,0,0,0.18);
      padding: 6px 9px;
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    .actions{ display:flex; gap:8px; flex-wrap:wrap; }

    .stack{ display:flex; flex-direction:column; gap:10px; }

    .small{ font-size: 12px; color: var(--muted); line-height:1.45; }
    .small.warn{ color: #ffd38a; }
    .small.err{ color: var(--red); }

    .history{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height: 380px;
      overflow:auto;
      padding-right: 4px;
    }

    .hitem{
      border: 1px solid rgba(209,161,75,0.12);
      background: rgba(0,0,0,0.18);
      border-radius: 14px;
      padding: 10px;
    }
    .hitem .top{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .hitem .top b{
      font-size: 12px;
      letter-spacing: 0.2px;
    }
    .hitem .time{
      font-size: 11px;
      color: var(--dim);
      white-space:nowrap;
    }
    .hitem .desc{
      margin-top:6px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.60);
      border: 1px solid rgba(209,161,75,0.22);
      color: var(--ink);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .16s ease, transform .16s ease;
      font-size: 12px;
      max-width: min(780px, calc(100vw - 26px));
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-4px);
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 8px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Crusade Intelligence Briefings (GM)</h1>
        <div class="sub">
          GM ‚Äúswitcher‚Äù page. Open <span class="kbd">viewer.html</span> on the projector/phones.
          This page publishes pinned intel to your Apps Script backend. Hotkeys: <span class="kbd">D</span> draw, <span class="kbd">C</span> copy.
        </div>
      </div>
      <div class="pill" id="netPill">Backend: Booting‚Ä¶</div>
    </header>

    <section class="panel">
      <div class="controls">
        <div class="field">
          <label for="count">Draw Count</label>
          <input id="count" type="number" min="1" max="8" value="3" />
        </div>

        <div class="field">
          <label for="category">Category Filter</label>
          <select id="category">
            <option value="__all__">All Categories</option>
          </select>
        </div>

        <div class="field">
          <label for="mode">Draw Mode</label>
          <select id="mode">
            <option value="unique">Unique (no repeats until deck exhausted)</option>
            <option value="any">Any (repeats allowed)</option>
          </select>
        </div>

        <div class="field">
          <label for="room">Room</label>
          <input id="room" type="text" placeholder="default" />
        </div>

        <div class="field">
          <label for="gmKey">GM Key</label>
          <input id="gmKey" type="password" placeholder="(stored locally in your browser)" />
        </div>

        <div class="btnrow">
          <button class="primary" id="drawBtn">Draw Briefing</button>
          <button id="copyBtn">Copy Briefing</button>
          <button id="pushBtn" title="Publish pinned/status to viewer">Publish</button>
          <button class="danger" id="resetBtn">Reset Local</button>
        </div>
      </div>

      <div class="grid">
        <div class="leftcol stack">
          <div class="card">
            <div class="small" id="deckStatus">Loading deck‚Ä¶</div>
            <div class="small" id="remoteStatus" style="margin-top:6px;">Loading backend state‚Ä¶</div>
            <div class="small warn" style="margin-top:8px;">
              Tip: Don‚Äôt hardcode the GM key into the file. Keep it in this input only.
            </div>
          </div>

          <div class="card">
            <label for="viewerSubtitle" style="display:block;margin-bottom:6px;">Viewer Subtitle</label>
            <input id="viewerSubtitle" type="text" placeholder="Optional line shown on viewer..." />
            <div class="small" style="margin-top:8px;">Example: ‚ÄúCampaign Turn 4 ‚Äî Vox traffic unstable.‚Äù</div>
          </div>

          <div id="drawArea" class="stack"></div>
        </div>

        <div class="rightcol stack">
          <div class="card">
            <h3 class="ctitle" style="margin:0 0 6px;">Pinned / Status Board (Published)</h3>
            <div class="small">This is what players see on <span class="kbd">viewer.html</span>. Use Focus to spotlight one card.</div>
            <div class="history" id="statusBoard"></div>
          </div>

          <div class="card">
            <h3 class="ctitle" style="margin:0 0 6px;">Draw History</h3>
            <div class="small">Quick log (local).</div>
            <div class="history" id="history"></div>
          </div>
        </div>
      </div>
    </section>

    <div class="toast" id="toast"></div>
  </div>

<script>
(() => {
  // ===== CONFIG =====
  const APPS_SCRIPT_BASE =
    "https://script.google.com/macros/s/AKfycbwKW6HJ2DkpxoAqLgwA5AeeA9_GvlBq7Fc8svttiLyML14wRUDuI5KAH7iQO4ns0hds/exec";

  const DECK_URL = "./briefing_deck.json";

  const LS = {
    seen: "crusadeIntel_seen_v1",
    history: "crusadeIntel_history_v1",

    // We keep a local cache of the last *published* state (so GM UI shows it even if backend is down)
    publishedCache: "crusadeIntel_published_cache_v1",

    // Store these locally so you don't retype every time
    room: "crusadeIntel_room_v1",
    gmKey: "crusadeIntel_gmkey_v1",
    subtitle: "crusadeIntel_subtitle_v1"
  };

  const els = {
    netPill: document.getElementById("netPill"),
    deckStatus: document.getElementById("deckStatus"),
    remoteStatus: document.getElementById("remoteStatus"),

    count: document.getElementById("count"),
    category: document.getElementById("category"),
    mode: document.getElementById("mode"),
    room: document.getElementById("room"),
    gmKey: document.getElementById("gmKey"),
    viewerSubtitle: document.getElementById("viewerSubtitle"),

    drawBtn: document.getElementById("drawBtn"),
    copyBtn: document.getElementById("copyBtn"),
    pushBtn: document.getElementById("pushBtn"),
    resetBtn: document.getElementById("resetBtn"),

    drawArea: document.getElementById("drawArea"),
    statusBoard: document.getElementById("statusBoard"),
    history: document.getElementById("history"),
    toast: document.getElementById("toast")
  };

  let DECK = null;
  let lastDraw = [];

  // Published/shared state (the actual program feed)
  let publishedState = {
    updatedAt: 0,
    subtitle: "",
    pinned: [],
    focusCardId: ""
  };

  // ===== helpers =====
  function escapeHtml(str){
    return String(str ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function toast(msg){
    els.toast.textContent = msg;
    els.toast.classList.add("show");
    window.clearTimeout(toast._t);
    toast._t = window.setTimeout(() => els.toast.classList.remove("show"), 1400);
  }

  function loadLS(key, fallback){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return fallback;
      return JSON.parse(raw);
    }catch(e){
      return fallback;
    }
  }
  function saveLS(key, val){
    localStorage.setItem(key, JSON.stringify(val));
  }

  function confidenceDotClass(conf){
    const c = (conf || "").toLowerCase();
    if(c.includes("high")) return "high";
    if(c.includes("mod")) return "mod";
    return "low";
  }

  function statusLabel(status){
    switch(status){
      case "ongoing": return "Ongoing";
      case "resolved": return "Resolved";
      case "false": return "Misinformation";
      default: return "Pinned";
    }
  }

  function ensureCategoryOptions(cards){
    const cats = Array.from(new Set(cards.map(c => c.category))).sort();
    while(els.category.options.length > 1) els.category.remove(1);
    for(const cat of cats){
      const opt = document.createElement("option");
      opt.value = cat;
      opt.textContent = cat;
      els.category.appendChild(opt);
    }
  }

  function eligibleCards(cards){
    const cat = els.category.value;
    return cards.filter(c => (cat === "__all__" ? true : c.category === cat));
  }

  function drawCards(cards, count, mode){
    const pool = eligibleCards(cards);
    if(pool.length === 0) return [];

    if(mode === "any"){
      const out = [];
      for(let i=0;i<count;i++){
        out.push(pool[Math.floor(Math.random()*pool.length)]);
      }
      return out;
    }

    let seen = new Set(loadLS(LS.seen, []));
    let unseen = pool.filter(c => !seen.has(c.id));

    if(unseen.length < count){
      for(const c of pool){ seen.delete(c.id); }
      unseen = pool.slice();
      toast("Deck cycle refreshed for current filter.");
    }

    const out = [];
    const bag = unseen.slice();
    for(let i=0;i<count && bag.length;i++){
      const idx = Math.floor(Math.random()*bag.length);
      out.push(bag.splice(idx,1)[0]);
    }

    for(const c of out) seen.add(c.id);
    saveLS(LS.seen, Array.from(seen));
    return out;
  }

  function apiGetUrl(){
    const room = (els.room.value || "default").trim() || "default";
    return `${APPS_SCRIPT_BASE}?room=${encodeURIComponent(room)}`;
  }

  async function apiGetState(){
    const res = await fetch(apiGetUrl(), { cache: "no-store" });
    if(!res.ok) throw new Error(`Backend GET failed (${res.status})`);
    const data = await res.json();
    if(!data || data.ok !== true) throw new Error(data?.error || "Backend ok:false");
    return data.state;
  }

  async function apiPostState(state){
    const room = (els.room.value || "default").trim() || "default";
    const key = (els.gmKey.value || "").trim();

    if(!key){
      throw new Error("GM Key is blank. Enter it to publish.");
    }

    const payload = { room, key, state };

    const res = await fetch(APPS_SCRIPT_BASE, {
      method: "POST",
      headers: { "Content-Type": "text/plain;charset=utf-8" },
      body: JSON.stringify(payload)
    });

    // Apps Script often returns 200 even on logical error, so inspect JSON
    const data = await res.json().catch(() => null);
    if(!data || data.ok !== true){
      throw new Error(data?.error || `Publish failed (${res.status}).`);
    }
    return data.state; // should include updatedAt (server-stamped too)
  }

  function renderDraw(cards){
    els.drawArea.innerHTML = "";
    if(!cards.length){
      els.drawArea.innerHTML = `<div class="card"><div class="small">No cards drawn yet.</div></div>`;
      return;
    }
    for(const c of cards){
      els.drawArea.appendChild(makeDrawCardEl(c));
    }
  }

  function makeDrawCardEl(c){
    const published = publishedState.pinned.find(p => p.card_id === c.id);
    const currentStatus = published?.status || "";
    const currentNote = published?.note || "";

    const wrap = document.createElement("div");
    wrap.className = "card";

    wrap.innerHTML = `
      <div class="cardhead">
        <div>
          <div class="badge">
            <span class="dot ${confidenceDotClass(c.confidence)}"></span>
            <span>${escapeHtml(c.category)}</span>
            <span style="opacity:.65">‚Ä¢</span>
            <span>${escapeHtml((c.confidence || "Low"))} Confidence</span>
          </div>
          <h3 class="ctitle">${escapeHtml(c.title)}</h3>
        </div>
        <div class="pill">${escapeHtml(statusLabel(currentStatus || "pinned"))}</div>
      </div>

      <p class="ctext">${escapeHtml(c.text)}</p>

      <div class="meta">
        <div class="left">
          ${(c.tone || []).slice(0,4).map(t => `<span class="pill">#${escapeHtml(t)}</span>`).join("")}
          ${currentNote ? `<span class="pill" title="GM note">üóí ${escapeHtml(currentNote)}</span>` : ``}
        </div>
        <div class="actions">
          <button data-act="pin">Pin</button>
          <button data-act="ongoing">Ongoing</button>
          <button data-act="resolved">Resolved</button>
          <button data-act="false">Misinformation</button>
          <button data-act="note">Add Note</button>
          <button data-act="focus">Focus</button>
          <button data-act="unpin">Unpin</button>
        </div>
      </div>
    `;

    wrap.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", async () => {
        const act = btn.getAttribute("data-act");
        if(act === "note"){
          const current = publishedState.pinned.find(p => p.card_id === c.id)?.note || "";
          const next = prompt("GM note (short):", current);
          if(next === null) return;
          upsertPinned(c.id, currentStatus || "ongoing", next.trim());
          publishedState.focusCardId = c.id;
          await safePublish("Note saved + published.");
          renderStatusBoard();
          renderDraw(lastDraw);
          return;
        }

        if(act === "focus"){
          // focus does not require pin, but it only really matters if pinned exists
          publishedState.focusCardId = c.id;
          if(!publishedState.pinned.some(p => p.card_id === c.id)){
            upsertPinned(c.id, "ongoing", "");
          }
          await safePublish("Focused + published.");
          renderStatusBoard();
          renderDraw(lastDraw);
          return;
        }

        if(act === "unpin"){
          publishedState.pinned = publishedState.pinned.filter(p => p.card_id !== c.id);
          if(publishedState.focusCardId === c.id) publishedState.focusCardId = "";
          await safePublish("Unpinned + published.");
          renderStatusBoard();
          renderDraw(lastDraw);
          return;
        }

        // pin/status
        const status = (act === "pin") ? "ongoing" : act;
        upsertPinned(c.id, status, currentNote || "");
        publishedState.focusCardId = c.id;
        await safePublish(`${statusLabel(status)} + published.`);
        renderStatusBoard();
        renderDraw(lastDraw);
      });
    });

    return wrap;
  }

  function upsertPinned(cardId, status, note){
    const idx = publishedState.pinned.findIndex(p => p.card_id === cardId);
    const entry = {
      card_id: cardId,
      status: status || "ongoing",
      note: (note || "").slice(0, 200)
    };
    if(idx === -1) publishedState.pinned.unshift(entry);
    else publishedState.pinned[idx] = entry;
  }

  function renderStatusBoard(){
    els.statusBoard.innerHTML = "";
    const pinned = publishedState.pinned || [];
    if(pinned.length === 0){
      els.statusBoard.innerHTML = `<div class="small">No pinned intel published yet.</div>`;
      return;
    }

    for(const p of pinned){
      const card = (DECK?.cards || []).find(c => c.id === p.card_id);
      if(!card) continue;

      const isFocus = publishedState.focusCardId === p.card_id;

      const el = document.createElement("div");
      el.className = "hitem";
      el.innerHTML = `
        <div class="top">
          <b>${escapeHtml(card.title)}${isFocus ? " ‚Ä¢ (FOCUS)" : ""}</b>
          <span class="time">${escapeHtml(card.category)}</span>
        </div>
        <div class="desc">
          <span class="pill">${escapeHtml(statusLabel(p.status))}</span>
          ${p.note ? `<div style="margin-top:6px; color: var(--muted);">${escapeHtml(p.note)}</div>` : ``}
          <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
            <button data-sb="focus">Focus</button>
            <button data-sb="up">Move Up</button>
            <button data-sb="down">Move Down</button>
            <button data-sb="remove">Remove</button>
          </div>
        </div>
      `;

      el.querySelector('[data-sb="focus"]').addEventListener("click", async () => {
        publishedState.focusCardId = p.card_id;
        await safePublish("Focused + published.");
        renderStatusBoard();
        renderDraw(lastDraw);
      });

      el.querySelector('[data-sb="remove"]').addEventListener("click", async () => {
        publishedState.pinned = publishedState.pinned.filter(x => x.card_id !== p.card_id);
        if(publishedState.focusCardId === p.card_id) publishedState.focusCardId = "";
        await safePublish("Removed + published.");
        renderStatusBoard();
        renderDraw(lastDraw);
      });

      el.querySelector('[data-sb="up"]').addEventListener("click", async () => {
        const i = publishedState.pinned.findIndex(x => x.card_id === p.card_id);
        if(i > 0){
          const tmp = publishedState.pinned[i-1];
          publishedState.pinned[i-1] = publishedState.pinned[i];
          publishedState.pinned[i] = tmp;
          await safePublish("Reordered + published.");
          renderStatusBoard();
        }
      });

      el.querySelector('[data-sb="down"]').addEventListener("click", async () => {
        const i = publishedState.pinned.findIndex(x => x.card_id === p.card_id);
        if(i !== -1 && i < publishedState.pinned.length - 1){
          const tmp = publishedState.pinned[i+1];
          publishedState.pinned[i+1] = publishedState.pinned[i];
          publishedState.pinned[i] = tmp;
          await safePublish("Reordered + published.");
          renderStatusBoard();
        }
      });

      els.statusBoard.appendChild(el);
    }
  }

  function renderHistory(){
    const hist = loadLS(LS.history, []);
    els.history.innerHTML = "";
    if(hist.length === 0){
      els.history.innerHTML = `<div class="small">No draws yet.</div>`;
      return;
    }

    for(const h of hist.slice(0, 30)){
      const el = document.createElement("div");
      el.className = "hitem";
      el.innerHTML = `
        <div class="top">
          <b>${escapeHtml(h.title)}</b>
          <span class="time">${escapeHtml(h.time)}</span>
        </div>
        <div class="desc">${escapeHtml(h.category)} ‚Ä¢ ${escapeHtml(h.confidence || "Low")} Confidence</div>
      `;
      els.history.appendChild(el);
    }
  }

  function appendHistory(drawn){
    const hist = loadLS(LS.history, []);
    const stamp = new Date().toLocaleString();
    for(const c of drawn){
      hist.unshift({
        id: c.id,
        title: c.title,
        category: c.category,
        confidence: c.confidence,
        time: stamp
      });
    }
    saveLS(LS.history, hist.slice(0, 120));
    renderHistory();
  }

  function deckStatusLine(){
    const total = (DECK?.cards || []).length;
    const cat = els.category.value;
    const pool = eligibleCards(DECK.cards);
    const seen = new Set(loadLS(LS.seen, []));
    const poolSeen = pool.filter(c => seen.has(c.id)).length;
    const poolUnseen = pool.length - poolSeen;

    const catText = (cat === "__all__") ? "All Categories" : cat;
    return `Deck loaded: ${total} cards ‚Ä¢ Filter: ${catText} ‚Ä¢ In cycle: ${poolUnseen} unseen / ${pool.length} total (Unique mode)`;
  }

  function setNet(ok, msg){
    els.netPill.textContent = ok ? `Backend: Online` : `Backend: Offline`;
    els.netPill.style.borderColor = ok ? "rgba(63,191,127,0.35)" : "rgba(204,59,59,0.35)";
    els.netPill.style.background = ok ? "rgba(63,191,127,0.10)" : "rgba(204,59,59,0.10)";
    if(msg) els.remoteStatus.textContent = msg;
  }

  async function safePublish(successMsg){
    // keep subtitle in state + local
    publishedState.subtitle = els.viewerSubtitle.value.trim();
    saveLS(LS.subtitle, publishedState.subtitle);

    try{
      setNet(true, "Publishing‚Ä¶");
      const saved = await apiPostState(publishedState);
      publishedState = normalizeState(saved);
      saveLS(LS.publishedCache, publishedState);
      setNet(true, `Published ‚Ä¢ Updated: ${new Date(publishedState.updatedAt || Date.now()).toLocaleString()}`);
      toast(successMsg || "Published.");
    }catch(err){
      setNet(false, `Publish failed: ${err.message || String(err)}`);
      toast("Publish failed (see status).");
      // still keep local cache updated so you don't lose work
      saveLS(LS.publishedCache, publishedState);
    }
  }

  function normalizeState(s){
    const out = {
      updatedAt: Number(s?.updatedAt || 0),
      subtitle: String(s?.subtitle || ""),
      focusCardId: String(s?.focusCardId || ""),
      pinned: Array.isArray(s?.pinned) ? s.pinned.map(p => ({
        card_id: String(p.card_id || ""),
        status: String(p.status || "ongoing"),
        note: String(p.note || "")
      })).filter(p => p.card_id) : []
    };
    return out;
  }

  // ===== init =====
  async function init(){
    // restore local settings
    els.room.value = (localStorage.getItem(LS.room) || "default").replaceAll('"','') || "default";
    els.viewerSubtitle.value = (localStorage.getItem(LS.subtitle) || "").replaceAll('"','') || "";
    // GM key stored as plain string in LS; do not commit to repo
    const savedKey = localStorage.getItem(LS.gmKey);
    if(savedKey) els.gmKey.value = savedKey.replaceAll('"','');

    els.room.addEventListener("input", () => localStorage.setItem(LS.room, els.room.value.trim() || "default"));
    els.gmKey.addEventListener("input", () => localStorage.setItem(LS.gmKey, els.gmKey.value));
    els.viewerSubtitle.addEventListener("input", () => {
      localStorage.setItem(LS.subtitle, els.viewerSubtitle.value);
    });

    // Load deck
    try{
      const res = await fetch(DECK_URL, { cache: "no-store" });
      if(!res.ok) throw new Error(`Failed to load ${DECK_URL} (${res.status})`);
      DECK = await res.json();
      ensureCategoryOptions(DECK.cards);
      els.deckStatus.textContent = deckStatusLine();
    }catch(err){
      els.deckStatus.textContent = "Failed to load deck. Check briefing_deck.json in repo root.";
      els.remoteStatus.textContent = err.message || String(err);
      setNet(false);
      return;
    }

    // Load backend state (authoritative), else local cache fallback
    try{
      setNet(true, "Loading backend state‚Ä¶");
      const s = await apiGetState();
      publishedState = normalizeState(s);
      saveLS(LS.publishedCache, publishedState);
      setNet(true, `Loaded ‚Ä¢ Updated: ${new Date(publishedState.updatedAt || Date.now()).toLocaleString()}`);
    }catch(err){
      const cached = loadLS(LS.publishedCache, null);
      if(cached){
        publishedState = normalizeState(cached);
        setNet(false, `Backend load failed; using cached published state.`);
      } else {
        setNet(false, `Backend load failed; no cache yet.`);
      }
    }

    // Apply subtitle to local input if backend has one (unless you already typed something)
    if(!els.viewerSubtitle.value.trim() && publishedState.subtitle){
      els.viewerSubtitle.value = publishedState.subtitle;
      localStorage.setItem(LS.subtitle, publishedState.subtitle);
    }

    renderStatusBoard();
    renderHistory();
    renderDraw([]);

    // Events
    els.category.addEventListener("change", () => {
      els.deckStatus.textContent = deckStatusLine();
    });

    els.drawBtn.addEventListener("click", () => {
      const count = Math.max(1, Math.min(8, parseInt(els.count.value || "3", 10)));
      els.count.value = String(count);

      const mode = els.mode.value;
      lastDraw = drawCards(DECK.cards, count, mode);
      renderDraw(lastDraw);
      appendHistory(lastDraw);
      els.deckStatus.textContent = deckStatusLine();
      toast(`Drew ${lastDraw.length} card(s).`);
    });

    els.copyBtn.addEventListener("click", async () => {
      if(!lastDraw.length){
        toast("Nothing to copy yet. Draw first.");
        return;
      }
      const stamp = new Date().toLocaleString();
      const lines = [];
      lines.push("CRUSADE INTELLIGENCE BRIEFING");
      lines.push(`Generated: ${stamp}`);
      lines.push("");

      for(const c of lastDraw){
        lines.push(`[${c.category}] ${c.title} (${c.confidence || "Low"} Confidence)`);
        lines.push(c.text);
        lines.push("");
      }

      const txt = lines.join("\n");
      try{
        await navigator.clipboard.writeText(txt);
        toast("Briefing copied.");
      }catch(e){
        prompt("Copy briefing:", txt);
      }
    });

    els.pushBtn.addEventListener("click", async () => {
      await safePublish("Published.");
    });

    els.resetBtn.addEventListener("click", () => {
      if(!confirm("Reset LOCAL draw history + seen cycle? (Does not erase backend published state.)")) return;
      localStorage.removeItem(LS.seen);
      localStorage.removeItem(LS.history);
      lastDraw = [];
      renderHistory();
      renderDraw([]);
      els.deckStatus.textContent = deckStatusLine();
      toast("Local reset done.");
    });

    // Hotkeys
    window.addEventListener("keydown", (e) => {
      if(e.key.toLowerCase() === "d") els.drawBtn.click();
      if(e.key.toLowerCase() === "c") els.copyBtn.click();
    });

    toast("GM ready. Publish updates to push to viewer.");
  }

  init();
})();
</script>
</body>
</html>
